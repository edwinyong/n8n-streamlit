# Streamlit app to visualize AI-generated report data
# Auto-generated by Streamlit App Builder Agent

import json
from typing import Dict, List, Any, Optional

import pandas as pd
import streamlit as st
import altair as alt

# ---------------------------------------------------------------------
# Embedded report data (from provided JSON)
# ---------------------------------------------------------------------
REPORT_DATA: Dict[str, Any] = {
    "valid": True,
    "issues": [],
    "summary": [
        "Monthly sales in 2025 peaked in February at 181,249.13 and declined steadily through September, reaching a low of 18,826.01.",
        "There is a clear downward trend in total sales from Q1 to Q3 2025."
    ],
    "tables": [
        {
            "name": "Table",
            "columns": ["month", "total_sales"],
            "rows": [
                ["2025-01-01", 119626.18999999885],
                ["2025-02-01", 181249.12999999718],
                ["2025-03-01", 162391.27999999782],
                ["2025-04-01", 122584.14999999863],
                ["2025-05-01", 110036.75999999886],
                ["2025-06-01", 138457.01999999848],
                ["2025-07-01", 101228.30999999943],
                ["2025-08-01", 90910.37999999947],
                ["2025-09-01", 18826.00999999998]
            ]
        }
    ],
    "charts": [
        {
            "id": "monthly_sales_trend",
            "type": "line",
            "spec": {
                "xKey": "month",
                "yKey": "total_sales",
                "series": [
                    {
                        "name": "Total Sales",
                        "yKey": "total_sales"
                    }
                ]
            }
        }
    ],
    "echo": {
        "intent": "trend",
        "used": {
            "tables": ["`Haleon_Rewards_User_Performance_110925_SKUs`"],
            "columns": ["Upload_Date", "Total Sales Amount"]
        },
        "stats": {
            "elapsed": 0.020915359
        },
        "sql_present": True
    }
}

# ---------------------------------------------------------------------
# Utility functions
# ---------------------------------------------------------------------

def _coerce_datetime_cols(df: pd.DataFrame) -> pd.DataFrame:
    """Try to coerce object columns that look like datetimes into datetime dtype."""
    df = df.copy()
    for col in df.columns:
        if df[col].dtype == object:
            parsed = pd.to_datetime(df[col], errors="coerce")
            if parsed.notna().mean() >= 0.9:  # if most values parse as dates
                df[col] = parsed
    return df


def _coerce_numeric_cols(df: pd.DataFrame) -> pd.DataFrame:
    """Try to coerce object columns that look numeric into numeric dtype."""
    df = df.copy()
    for col in df.columns:
        if df[col].dtype == object:
            nums = pd.to_numeric(df[col], errors="coerce")
            if nums.notna().mean() >= 0.9:
                df[col] = nums
    return df


def build_tables(report: Dict[str, Any]) -> Dict[str, pd.DataFrame]:
    """Create DataFrames from report tables, applying light type inference."""
    table_map: Dict[str, pd.DataFrame] = {}
    for t in report.get("tables", []):
        name = t.get("name") or "Table"
        cols = t.get("columns", [])
        rows = t.get("rows", [])
        df = pd.DataFrame(rows, columns=cols)
        df = _coerce_numeric_cols(_coerce_datetime_cols(df))
        table_map[name] = df
    return table_map


def find_df_for_chart(table_map: Dict[str, pd.DataFrame], required_cols: List[str]) -> Optional[pd.DataFrame]:
    """Find a DataFrame that contains all required columns; fallback to first if none match."""
    for df in table_map.values():
        if set(required_cols).issubset(set(df.columns)):
            return df
    # Fallback: return first df if available
    return next(iter(table_map.values())) if table_map else None


def infer_altair_type(series: pd.Series) -> str:
    """Infer Altair type for a pandas Series."""
    if pd.api.types.is_datetime64_any_dtype(series):
        return "temporal"
    if pd.api.types.is_numeric_dtype(series):
        return "quantitative"
    return "nominal"


def melt_series(df: pd.DataFrame, x_key: str, series_defs: List[Dict[str, Any]]) -> pd.DataFrame:
    """Transform wide data with multiple y series into a tidy long format.
    If only one series, still return a long-format DataFrame for consistent charting.
    """
    long_frames = []
    for s in series_defs:
        y_key = s.get("yKey")
        name = s.get("name", y_key)
        if y_key not in df.columns:
            continue
        tmp = df[[x_key, y_key]].copy()
        tmp.rename(columns={y_key: "Value"}, inplace=True)
        tmp["Series"] = str(name)
        long_frames.append(tmp)
    if not long_frames:
        return pd.DataFrame(columns=[x_key, "Value", "Series"])  # empty safe df
    return pd.concat(long_frames, ignore_index=True)


def build_altair_chart(chart_def: Dict[str, Any], table_map: Dict[str, pd.DataFrame]) -> Optional[alt.Chart]:
    ctype = chart_def.get("type", "").lower()
    spec = chart_def.get("spec", {})

    # Common keys
    x_key = spec.get("xKey")
    y_key = spec.get("yKey")  # may be unused when multiple series provided
    series_defs = spec.get("series", [])

    # Determine required columns to find appropriate table
    required_cols = []
    if x_key:
        required_cols.append(x_key)
    y_keys = list({sd.get("yKey") for sd in series_defs if sd.get("yKey")})
    if not y_keys and y_key:
        y_keys = [y_key]
    required_cols.extend(y_keys)

    df = find_df_for_chart(table_map, required_cols)
    if df is None or x_key is None:
        return None

    # Prepare long-format dataframe for charting
    if not series_defs and y_key:
        series_defs = [{"name": y_key, "yKey": y_key}]
    long_df = melt_series(df, x_key, series_defs)

    # Infer types
    x_type = infer_altair_type(df[x_key]) if x_key in df.columns else "nominal"

    # Build chart based on type
    if ctype == "line":
        chart = (
            alt.Chart(long_df)
            .mark_line(point=True)
            .encode(
                x=alt.X(f"{x_key}:{'T' if x_type=='temporal' else ('Q' if x_type=='quantitative' else 'N')}", title=x_key),
                y=alt.Y("Value:Q", title="Value"),
                color=alt.Color("Series:N", title="Series"),
                tooltip=[
                    alt.Tooltip(f"{x_key}:{'T' if x_type=='temporal' else 'N'}", title=x_key),
                    alt.Tooltip("Series:N", title="Series"),
                    alt.Tooltip("Value:Q", title="Value", format=",.2f"),
                ],
            )
        )
        return chart

    # Future extensions for bar/pie/etc. can go here if needed.
    return None


# ---------------------------------------------------------------------
# Streamlit UI
# ---------------------------------------------------------------------

def main() -> None:
    st.set_page_config(page_title="AI Report Viewer", page_icon="ðŸ“ˆ", layout="wide")

    st.title("AI Report Viewer")

    # Validity and issues
    if not REPORT_DATA.get("valid", False):
        st.error("The provided report is marked as invalid.")
    if REPORT_DATA.get("issues"):
        with st.expander("Report Issues"):
            for i, issue in enumerate(REPORT_DATA["issues"], start=1):
                st.write(f"{i}. {issue}")

    # Summary section
    st.subheader("Summary")
    summary_items = REPORT_DATA.get("summary", [])
    if summary_items:
        # Render as bullet list markdown
        md_lines = ["- " + str(item) for item in summary_items]
        st.markdown("\n".join(md_lines))
    else:
        st.info("No summary provided.")

    # Build DataFrames from tables
    table_map = build_tables(REPORT_DATA)

    # Tables section
    st.subheader("Tables")
    if not table_map:
        st.info("No tables available.")
    else:
        for tname, df in table_map.items():
            st.markdown(f"**{tname}**")
            st.dataframe(df, use_container_width=True)
            # Optional: download
            csv_bytes = df.to_csv(index=False).encode("utf-8")
            st.download_button(
                label=f"Download {tname} as CSV",
                data=csv_bytes,
                file_name=f"{tname.replace(' ', '_').lower()}.csv",
                mime="text/csv",
                key=f"download_{tname}"
            )
            st.divider()

    # Charts section
    st.subheader("Charts")
    charts = REPORT_DATA.get("charts", [])
    if not charts:
        st.info("No charts available.")
    else:
        for ch in charts:
            chart_id = ch.get("id", "chart")
            st.markdown(f"**{chart_id}**")
            chart_obj = build_altair_chart(ch, table_map)
            if chart_obj is not None:
                st.altair_chart(chart_obj.properties(width="container", height=360), use_container_width=True)
            else:
                st.warning(f"Chart '{chart_id}' could not be rendered.")
            st.divider()

    # Debug/Raw data
    with st.expander("Raw Report JSON"):
        st.code(json.dumps(REPORT_DATA, indent=2, default=str), language="json")


if __name__ == "__main__":
    main()
