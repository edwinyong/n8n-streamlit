# Streamlit app autogenerated from report JSON
# Libraries: streamlit, pandas, altair

import streamlit as st
import pandas as pd
import altair as alt
from typing import Dict, Any, List

# =========================
# Embedded report JSON data
# =========================
report: Dict[str, Any] = {
    "valid": True,
    "issues": [],
    "summary": [
        "Registered purchasers decreased by 23.43% from Q1 (4,998) to Q2 (3,826) in 2025.",
        "Total sales dropped by 19.88% from Q1 (463,266.60) to Q2 (371,077.93) in 2025."
    ],
    "tables": [
        {
            "name": "Table",
            "columns": ["period", "registered_purchasers", "total_sales"],
            "rows": [
                ["2025 Q1", "4998", 463266.6000000094],
                ["2025 Q2", "3826", 371077.9300000016]
            ]
        }
    ],
    "charts": [
        {
            "id": "main",
            "type": "groupedBar",
            "spec": {
                "xKey": "period",
                "yKey": "value",
                "series": [
                    {"name": "Registered Purchasers", "yKey": "registered_purchasers"},
                    {"name": "Total Sales", "yKey": "total_sales"}
                ]
            }
        }
    ],
    "echo": {
        "intent": "comparison_totals",
        "used": {
            "tables": [
                "`Haleon_Rewards_User_Performance_110925_SKUs`",
                "`Haleon_Rewards_User_Performance_110925_user_list`"
            ],
            "columns": ["Upload_Date", "Total Sales Amount", "comuserid", "user_id"]
        },
        "stats": {"elapsed": 0.080062009},
        "sql_present": True
    }
}

# =========================
# Page config
# =========================
st.set_page_config(page_title="2025 Q1 vs Q2 Report Dashboard", layout="wide")

# =========================
# Utility functions
# =========================

def coerce_numeric(df: pd.DataFrame, cols: List[str]) -> pd.DataFrame:
    for c in cols:
        if c in df.columns:
            df[c] = pd.to_numeric(df[c], errors="coerce")
    return df


def render_summary(summary_items: List[str]):
    if not summary_items:
        return
    st.subheader("Summary")
    bullets = "\n".join([f"- {s}" for s in summary_items])
    st.markdown(bullets)


def render_tables(tables: List[Dict[str, Any]]) -> Dict[str, pd.DataFrame]:
    st.subheader("Tables")
    dfs: Dict[str, pd.DataFrame] = {}
    for idx, t in enumerate(tables):
        name = t.get("name") or f"Table {idx+1}"
        columns = t.get("columns", [])
        rows = t.get("rows", [])
        df = pd.DataFrame(rows, columns=columns)
        # Attempt to coerce known numeric columns
        df = coerce_numeric(df, ["registered_purchasers", "total_sales"])  # domain-specific hints
        dfs[name] = df
        st.markdown(f"**{name}**")
        st.dataframe(df, use_container_width=True)
    return dfs


def make_grouped_bar(df: pd.DataFrame, x_key: str, value_key: str, series_spec: List[Dict[str, str]], title: str = None) -> alt.Chart:
    # Validate presence of x_key and series yKeys
    y_keys = [s.get("yKey") for s in series_spec]
    name_map = {s.get("yKey"): s.get("name", s.get("yKey")) for s in series_spec}

    # Melt to long format
    long_df = pd.melt(
        df[[x_key] + [yk for yk in y_keys if yk in df.columns]].copy(),
        id_vars=[x_key],
        value_vars=[yk for yk in y_keys if yk in df.columns],
        var_name="series",
        value_name=value_key,
    )
    # Attach friendly series names
    long_df["Series Name"] = long_df["series"].map(name_map).fillna(long_df["series"])  # for legend

    # Ensure numeric values
    long_df[value_key] = pd.to_numeric(long_df[value_key], errors="coerce")

    # Build grouped bar using xOffset
    chart = (
        alt.Chart(long_df, title=title)
        .mark_bar()
        .encode(
            x=alt.X(f"{x_key}:N", title=x_key),
            y=alt.Y(f"{value_key}:Q", title="Value"),
            color=alt.Color("Series Name:N", legend=alt.Legend(title="Series")),
            xOffset=alt.XOffset("Series Name:N"),
            tooltip=[
                alt.Tooltip(f"{x_key}:N", title=x_key),
                alt.Tooltip("Series Name:N", title="Series"),
                alt.Tooltip(f"{value_key}:Q", title="Value", format=",.2f"),
            ],
        )
    )

    return chart


def render_charts(charts: List[Dict[str, Any]], table_sources: Dict[str, pd.DataFrame]):
    if not charts:
        return
    st.subheader("Charts")

    # Choose a default source table (first provided)
    default_df = next(iter(table_sources.values())) if table_sources else pd.DataFrame()

    for ch in charts:
        ch_type = ch.get("type")
        ch_id = ch.get("id", "chart")
        spec = ch.get("spec", {})

        st.markdown(f"**Chart: {ch_id} ({ch_type})**")

        if ch_type == "groupedBar":
            x_key = spec.get("xKey", "period")
            value_key = spec.get("yKey", "value")
            series_spec = spec.get("series", [])
            # Build from default_df; extend here if future JSON includes explicit dataset links
            if default_df.empty or x_key not in default_df.columns:
                st.info("Chart could not be rendered because required columns were not found in the data.")
                continue
            chart = make_grouped_bar(default_df, x_key=x_key, value_key=value_key, series_spec=series_spec,
                                     title="Grouped Bar")
            st.altair_chart(chart, use_container_width=True)
        else:
            st.info(f"Unsupported chart type: {ch_type}.")


# =========================
# App layout
# =========================
st.title("2025 Q1 vs Q2 Comparison Dashboard")

# Render summary
render_summary(report.get("summary", []))

# Render tables
tables_df_map = render_tables(report.get("tables", []))

# Render charts
render_charts(report.get("charts", []), tables_df_map)

# Optional: Reveal metadata
with st.expander("Report metadata"):
    st.json(report.get("echo", {}))
